// GAME SCENE CODE
import Phaser from 'phaser'; 
import NetSync from '../systems/NetSync.js';
import { networkService } from '../services/NetworkService.js';
import AnimController from '../systems/AnimController.js';
import { CFG } from '../core/Config.js';
import { isDesktopLike } from '../utils/DeviceMode.js';
import { computePortraitZoom, computeDesktopZoom, lerpZoom } from '../systems/PortraitZoom.js';

export default class GameScene extends Phaser.Scene {
  constructor() {
    super('Game');
    this.otherPlayers = {}; 
    this.enemySprites = {};
    this.bulletSprites = {};
    this._zoomCfg = { BASE_W:480, BASE_H:270, PLAYER_FRAME_H:24, TARGET_PLAYER_PX:20, MIN_WORLD_WIDTH:240, Z_MIN:0.75, Z_MAX:1.0, LERP:0.12 };
    this.localPlayerKey = null;
    this.latestState = null;
  }

  init(data) {
    this.joinRoomId = data?.joinRoomId || null;
    this.profile = data?.profile || { displayName: 'Pilot' };
  }

  async create() {
    this.scoreText = this.add.text(6,6,'Score: 0',{fontFamily:'monospace',fontSize:12,color:'#fff'}).setScrollFactor(0).setDepth(100);
    this.debugText = this.add.text(6,22,'',{fontFamily:'monospace',fontSize:11,color:'#ccc'}).setScrollFactor(0).setDepth(100);
    this.velText = this.add.text(6, 38, '', {
      fontFamily: 'monospace',
      fontSize: 11,
      color: '#0f0'
    }).setScrollFactor(0).setDepth(100);

    this.player = this.physics.add.sprite(160,90,'player',0).setDepth(2).setOrigin(0.5);
    this.player.setCollideWorldBounds(true);
    this.pAnim = new AnimController(this.player, { 
      idle_front:'p_idle_front', 
      idle_back:'p_idle_back', 
      walk_front:'p_walk_front', 
      walk_back:'p_walk_back' 
    });

    this.keys = this.input.keyboard.addKeys({ 
      W:Phaser.Input.Keyboard.KeyCodes.W, 
      A:Phaser.Input.Keyboard.KeyCodes.A, 
      S:Phaser.Input.Keyboard.KeyCodes.S, 
      D:Phaser.Input.Keyboard.KeyCodes.D 
    });
    this.cursors = this.input.keyboard.createCursorKeys();

    this.cameras.main.startFollow(this.player,true,0.2,0.2);
    this.physics.world.setBounds(-this.scale.width,-this.scale.height,this.scale.width*3,this.scale.height*3);
    this._applyZoom(true);
    this.scale.on('resize', ()=> this._applyZoom(true));

    try {
      await networkService.joinRoom(this.joinRoomId);
    } catch (e) {
      this.time.delayedCall(1000, ()=> this.scene.start('WaitingRoom'));
      return;
    }

    this.localPlayerKey = networkService.playerKey || networkService.sessionId || null;

    this.netSync = new NetSync(networkService, this, { interpMs: 200, predStrength: 0.0 });
    await this.netSync.start();

    this._lastRenderAt = Date.now();
  }

  _applyZoom(jump=false) {
    const cam = this.cameras.main;
    if (!cam) return;
    const vw = this.scale.width, vh = this.scale.height;
    let targetZoom = 1;
    try {
      if (isDesktopLike(vw,vh)) targetZoom = computeDesktopZoom({viewW:vw, viewH:vh, baseW:this._zoomCfg.BASE_W, baseH:this._zoomCfg.BASE_H});
      else targetZoom = computePortraitZoom({viewW:vw, viewH:vh, playerFrameH:this._zoomCfg.PLAYER_FRAME_H, TARGET_PLAYER_PX:this._zoomCfg.TARGET_PLAYER_PX, MIN_WORLD_WIDTH:this._zoomCfg.MIN_WORLD_WIDTH, Z_MIN:this._zoomCfg.Z_MIN, Z_MAX:this._zoomCfg.Z_MAX});
    } catch(e) { targetZoom = 1; }
    if (jump) cam.setZoom(targetZoom); else lerpZoom(cam, targetZoom, this._zoomCfg.LERP);
  }

  update(time, delta) {
    this._updateLocalInputRegistry();

    if (this.netSync) {
      this.netSync.renderInterpolated(({ players = {}, enemies = {}, bullets = {}, snapshotMeta = {} }) => {
        const localKey = this.localPlayerKey || networkService.playerKey || networkService.sessionId;

        if (this.debugText) {
          const ids = (snapshotMeta?.playersIds || Object.keys(players) || []).slice(0,6).map(s => (s||'').slice(0,6)).join(',');
          this.debugText.setText(`players:${Object.keys(players).length} ids:${ids}\nmyKey:${(localKey||'').slice(0,8)}`);
        }

        for (const id in players) {
          const p = players[id] || {};

          if (id === localKey) {
            const blend = 0.3;
            if (this.player && typeof p.x === 'number' && typeof p.y === 'number') {
              this.player.x = Phaser.Math.Linear(this.player.x, p.x, blend);
              this.player.y = Phaser.Math.Linear(this.player.y, p.y, blend);
              if (this.player.body) this.player.body.setVelocity(0, 0);
              if (this.scoreText) this.scoreText.setText(`Score: ${Math.floor(p.score||0)}`);
            }
            continue;
          }

          let ent = this.otherPlayers[id];
          if (!ent) {
            const spr = this.add.sprite(p.x || 0, p.y || 0, 'player').setDepth(1).setOrigin(0.5).setScale(1);
            const anim = new AnimController(spr, { idle_front:'p_idle_front', idle_back:'p_idle_back', walk_front:'p_walk_front', walk_back:'p_walk_back' });
            ent = { sprite: spr, anim, lastPos: { x: p.x || 0, y: p.y || 0, t: Date.now() } };
            this.otherPlayers[id] = ent;
          } else {
            const now = Date.now();
            const dt = Math.max(1, now - (ent.lastPos.t || now));
            const vx = (p.x - (ent.lastPos.x||p.x)) / (dt / 1000);
            const vy = (p.y - (ent.lastPos.y||p.y)) / (dt / 1000);

            if (typeof p.x === 'number' && typeof p.y === 'number') {
              ent.sprite.x = Phaser.Math.Linear(ent.sprite.x, p.x, 0.6);
              ent.sprite.y = Phaser.Math.Linear(ent.sprite.y, p.y, 0.6);
            }

            ent.anim.updateFromVelocity(vx, vy);

            ent.lastPos.x = (typeof p.x === 'number') ? p.x : ent.lastPos.x;
            ent.lastPos.y = (typeof p.y === 'number') ? p.y : ent.lastPos.y;
            ent.lastPos.t = now;
          }
        }

        for (const id in enemies) {
          const e = enemies[id] || {};
          let s = this.enemySprites[id];
          if (!s) {
            s = this.add.sprite(e.x || 0, e.y || 0, 'e_walk_front').setScale(0.7).setDepth(1).setOrigin(0.5);
            this.enemySprites[id] = s;
          } else if (typeof e.x === 'number' && typeof e.y === 'number') {
            s.x = e.x; s.y = e.y;
          }
        }

        for (const id in bullets) {
          const b = bullets[id] || {};
          let s = this.bulletSprites[id];
          if (!s) {
            s = this.add.sprite(b.x || 0, b.y || 0, 'bullet').setScale(0.5).setDepth(2).setOrigin(0.5);
            this.bulletSprites[id] = s;
          } else if (typeof b.x === 'number' && typeof b.y === 'number') {
            s.x = b.x; s.y = b.y;
          }
        }

        for (const id in this.otherPlayers) if (!players[id]) { try{ this.otherPlayers[id].sprite.destroy(); }catch{} delete this.otherPlayers[id]; }
        for (const id in this.enemySprites) if (!enemies[id]) { try{ this.enemySprites[id].destroy(); }catch{} delete this.enemySprites[id]; }
        for (const id in this.bulletSprites) if (!bullets[id]) { try{ this.bulletSprites[id].destroy(); }catch{} delete this.bulletSprites[id]; }
      });
    }

    if (this.pAnim && this.player?.body) this.pAnim.updateFromVelocity(this.player.body.velocity.x, this.player.body.velocity.y);
    if (this.player && this.player.body && this.velText) {
      const vx = this.player.body.velocity.x.toFixed(1);
      const vy = this.player.body.velocity.y.toFixed(1);
      const px = this.player.x.toFixed(1);
      const py = this.player.y.toFixed(1);
      this.velText.setText(`pos(${px}, ${py}) vel(${vx}, ${vy})`);
    }
  }

  _updateLocalInputRegistry() {
    const registry = {};
    const vx = ((this.keys?.D?.isDown ? 1 : 0) - (this.keys?.A?.isDown ? 1 : 0));
    const vy = ((this.keys?.S?.isDown ? 1 : 0) - (this.keys?.W?.isDown ? 1 : 0));
    registry.vector = { x: vx, y: vy };

    if (this.input.activePointer && this.input.activePointer.isDown) {
      registry.aim = { x: this.input.activePointer.worldX, y: this.input.activePointer.worldY };
      registry.aimHeld = true;
    } else {
      registry.aim = null;
      registry.aimHeld = false;
    }

    try { this.registry.set('input', registry); } catch (e) {}

    try {
      const speed = (CFG?.player?.speed || 80);
      const mag = Math.hypot(vx, vy);
      let localVx = 0, localVy = 0;
      if (mag > 0) {
        localVx = (vx / mag) * speed;
        localVy = (vy / mag) * speed;
      }
      if (this.player && this.player.body && typeof this.player.body.setVelocity === 'function') {
        this.player.body.setVelocity(localVx, localVy);
      }
    } catch (_) {}

    try {
      networkService.sendInput({
        up: !!(vy < 0),
        down: !!(vy > 0),
        left: !!(vx < 0),
        right: !!(vx > 0),
        aimX: registry.aim?.x || null,
        aimY: registry.aim?.y || null,
        seq: (this._inputSeq = (this._inputSeq || 0) + 1)
      });
    } catch (_) {}
  }

  shutdown() {
    this.netSync?.stop();
    for (const k in this.otherPlayers) { try{ this.otherPlayers[k].sprite.destroy(); }catch{} }
    for (const k in this.enemySprites) { try{ this.enemySprites[k].destroy(); }catch{} }
    for (const k in this.bulletSprites) { try{ this.bulletSprites[k].destroy(); }catch{} }
  }
}








//GAME ROOM CODE

import { Room } from "@colyseus/core";
import { Schema, MapSchema, type } from "@colyseus/schema";

/* -------------------------
   Schema definitions
   ------------------------- */
class PlayerState extends Schema {
  constructor() {
    super();
    this.id = "";
    this.address = null;
    this.x = 0;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;
    this.hp = 5;
    this.alive = true;
    this.score = 0;
  }
}
type("string")(PlayerState.prototype, "id");
type("string")(PlayerState.prototype, "address");
type("number")(PlayerState.prototype, "x");
type("number")(PlayerState.prototype, "y");
type("number")(PlayerState.prototype, "vx");
type("number")(PlayerState.prototype, "vy");
type("number")(PlayerState.prototype, "hp");
type("boolean")(PlayerState.prototype, "alive");
type("number")(PlayerState.prototype, "score");

class EnemyState extends Schema {
  constructor() {
    super();
    this.id = "";
    this.x = 0;
    this.y = 0;
    this.hp = 3;
    this.alive = true;
  }
}
type("string")(EnemyState.prototype, "id");
type("number")(EnemyState.prototype, "x");
type("number")(EnemyState.prototype, "y");
type("number")(EnemyState.prototype, "hp");
type("boolean")(EnemyState.prototype, "alive");

class BulletState extends Schema {
  constructor() {
    super();
    this.x = 0;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;
    this.ttl = 60;
    this.owner = "";
  }
}
type("number")(BulletState.prototype, "x");
type("number")(BulletState.prototype, "y");
type("number")(BulletState.prototype, "vx");
type("number")(BulletState.prototype, "vy");
type("number")(BulletState.prototype, "ttl");
type("string")(BulletState.prototype, "owner");

class GameState extends Schema {
  constructor() {
    super();
    this.players = new MapSchema();
    this.enemies = new MapSchema();
    this.bullets = new MapSchema();
    this.tick = 0;
  }
}
type({ map: PlayerState })(GameState.prototype, "players");
type({ map: EnemyState })(GameState.prototype, "enemies");
type({ map: BulletState })(GameState.prototype, "bullets");
type("number")(GameState.prototype, "tick");

/* -------------------------
   GameRoom implementation
   ------------------------- */
export class GameRoom extends Room {
  onCreate(options) {
    this.setState(new GameState());

    this.sessionToPlayerKey = {};
    this.playerKeyToSession = {};

    this.allowedAddresses = (options?.allowedAddresses && Array.isArray(options.allowedAddresses))
      ? options.allowedAddresses.map(a => String(a).toLowerCase())
      : null;

    this._tickIntervalMs = 50; // 20 tps
    this.setSimulationInterval((deltaTime) => {
      try { this._tick(deltaTime); } catch (_) {}
    }, this._tickIntervalMs);

    this.onMessage("input", (client, data) => {
      try { this._handleInput(client, data); } catch (_) {}
    });

    this.onMessage("ping", (client) => client.send("pong", { t: Date.now() }));
  }

  onJoin(client, options) {
    if (!this.state) {
      try { client.leave(); } catch (_) {}
      return;
    }

    const supplied = options?.playerId || options?.playerKey || options?.address || null;
    const normalized = supplied ? String(supplied).toLowerCase() : null;
    const playerKey = normalized || client.sessionId;

    if (this.allowedAddresses && normalized && !this.allowedAddresses.includes(normalized)) {
      try { client.send("error", { message: "not-allowed" }); } catch (_) {}
      try { client.leave(); } catch (_) {}
      return;
    }

    this.sessionToPlayerKey[client.sessionId] = playerKey;
    this.playerKeyToSession[playerKey] = client.sessionId;

    if (this.state.players.has(playerKey)) return;

    const p = new PlayerState();
    p.id = playerKey;
    p.address = normalized || null;
    p.x = 160 + (Math.random() - 0.5) * 60;
    p.y = 90 + (Math.random() - 0.5) * 60;
    p.vx = 0; p.vy = 0; p.hp = 5; p.alive = true; p.score = 0;
    this.state.players.set(playerKey, p);
  }

  onLeave(client, consented) {
    try {
      const pk = this.sessionToPlayerKey[client.sessionId];
      if (pk) {
        delete this.playerKeyToSession[pk];
        delete this.sessionToPlayerKey[client.sessionId];
        const ps = this.state?.players?.get(pk);
        if (ps) ps.alive = false;
      }
    } catch (_) {}
  }

  onDispose() {}

  _handleInput(client, data) {
    const sess = client.sessionId;
    const playerKey = this.sessionToPlayerKey[sess] || sess;
    const players = this.state?.players;
    if (!players || !players.has(playerKey)) return;

    const p = players.get(playerKey);

    const speed = 80;
    let vx = 0, vy = 0;
    if (data.left) vx -= 1;
    if (data.right) vx += 1;
    if (data.up) vy -= 1;
    if (data.down) vy += 1;

    const mag = Math.hypot(vx, vy) || 1;
    vx = mag === 0 ? 0 : (vx / mag) * speed;
    vy = mag === 0 ? 0 : (vy / mag) * speed;

    p.vx = vx;
    p.vy = vy;

    if (data.shoot) this._handleShoot(playerKey, data);
  }

  _tick(deltaTime) {
    if (!this.state) return;
    const dt = (deltaTime ?? this._tickIntervalMs) / 1000;

    for (const [key, p] of this.state.players.entries()) {
      if (!p || !p.alive) continue;
      p.x += (p.vx || 0) * dt;
      p.y += (p.vy || 0) * dt;
      p.x = Math.max(-20, Math.min(340, p.x));
      p.y = Math.max(-20, Math.min(220, p.y));
      if (p.hp <= 0 && p.alive) p.alive = false;
    }

    if (Math.random() < 0.03) this._spawnEnemy();

    const alivePlayers = Array.from(this.state.players.values()).filter(x => x && x.alive);
    for (const [eid, e] of this.state.enemies.entries()) {
      if (!e || !e.alive) continue;
      if (alivePlayers.length === 0) continue;
      const target = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
      const dx = target.x - e.x, dy = target.y - e.y;
      const dist = Math.hypot(dx, dy) || 1;
      const speed = 20;
      e.x += (dx / dist) * speed * dt;
      e.y += (dy / dist) * speed * dt;
      if (Math.hypot(e.x - target.x, e.y - target.y) < 6) {
        target.hp -= 1;
        if (target.hp <= 0) target.alive = false;
      }
    }

    const bulletsToDelete = [];
    for (const [id, b] of this.state.bullets.entries()) {
      if (!b) continue;
      b.x += (b.vx || 0) * dt;
      b.y += (b.vy || 0) * dt;
      b.ttl = (b.ttl || 60) - 1;
      if (b.ttl <= 0 || b.x < -50 || b.y < -50 || b.x > 400 || b.y > 300) {
        bulletsToDelete.push(id);
      } else {
        for (const [eid, e] of this.state.enemies.entries()) {
          if (!e || !e.alive) continue;
          if (Math.hypot(e.x - b.x, e.y - b.y) < 6) {
            e.hp -= 1;
            if (e.hp <= 0) e.alive = false;
            bulletsToDelete.push(id);
            break;
          }
        }
      }
    }
    for (const id of bulletsToDelete) this.state.bullets.delete(id);

    for (const [eid, e] of this.state.enemies.entries()) {
      if (!e.alive) this.state.enemies.delete(eid);
    }

    this.state.tick = (this.state.tick || 0) + 1;
  }

  _spawnEnemy() {
    const id = `e_${Math.random().toString(36).slice(2, 8)}`;
    const e = null;
    const edge = Math.floor(Math.random() * 4);
    if (edge === 0) { e.x = Math.random() * 320; e.y = -10; }
    else if (edge === 1) { e.x = 330; e.y = Math.random() * 180; }
    else if (edge === 2) { e.x = Math.random() * 320; e.y = 190; }
    else { e.x = -10; e.y = Math.random() * 180; }
    e.id = id; e.hp = 3; e.alive = true;
    this.state.enemies.set(id, e);
  }

  _handleShoot(playerKey, data) {
    const p = this.state.players.get(playerKey);
    if (!p) return;
    const id = `b_${Math.random().toString(36).slice(2, 8)}`;
    const bx = p.x, by = p.y;
    const aimX = data.aimX ?? (p.x + 20);
    const aimY = data.aimY ?? p.y;
    const dx = aimX - bx, dy = aimY - by;
    const dist = Math.hypot(dx, dy) || 1;
    const speed = 220;
    const bullet = new BulletState();
    bullet.x = bx; bullet.y = by;
    bullet.vx = (dx / dist) * speed;
    bullet.vy = (dy / dist) * speed;
    bullet.owner = playerKey;
    bullet.ttl = 60;
    this.state.bullets.set(id, bullet);
  }
}



// NETWORK SERVICE CODE 
import { Client } from "colyseus.js";
import { walletService } from './WalletService.js';

export class NetworkService {
  constructor() {
    this.colyseusClient = new Client(import.meta.env.VITE_COLYSEUS_WS || 'ws://localhost:2567');
    this.lobbyRoom = null;
    this.gameRoom = null;
    this.lobbyState = null;
    this.gameState = null;
    this.sessionId = null;
    this.playerKey = null;
    this._lastLobbyError = null;
    this._lastInvite = null;
    this._lastMatchmaking = null;
    this._lastGameReady = null;
    this._inputSeq = 0;

    // callbacks UI can set
    this.onInvite = null;
    this.onGameReady = null;
    this.onGameReadyError = null;
  }

  get room() { return this.gameRoom; }
  get state() { return this.gameState; }

  // ---------------- Lobby ----------------
  async connectToLobby() {
    // join or create the shared lobby
    this.lobbyRoom = await this.colyseusClient.joinOrCreate('borc_lobby');
    this.sessionId = this.lobbyRoom.sessionId;

    this.lobbyRoom.onMessage('lobby_update', (data) => {
      this.lobbyState = data;
      console.debug('[Network] lobby_update', data);
    });

    this.lobbyRoom.onMessage('invite', (data) => {
      console.debug('[Network] invite received', data);
      this._lastInvite = data;
      if (this.onInvite) try { this.onInvite(data); } catch (_) {}
    });

    // When server signals a created game room for us:
    this.lobbyRoom.onMessage('game_ready', (data) => {
      console.debug('[Network] game_ready', data);
      this._lastGameReady = data;
      // auto-join the game room (non-blocking). data may include playerKey
      this.joinGameRoomById(data.roomId)
        .then(room => {
          console.info('[Network] joined game room', data.roomId);
          if (this.onGameReady) try { this.onGameReady(data); } catch (_) {}
        })
        .catch(err => {
          console.error('[Network] failed to join game room', err);
          if (this.onGameReadyError) try { this.onGameReadyError(err); } catch (_) {}
        });
    });

    this.lobbyRoom.onMessage('matchmaking_status', (m) => {
      this._lastMatchmaking = m;
      console.debug('[Network] matchmaking_status', m);
    });

    this.lobbyRoom.onMessage('error', (payload) => {
      this._lastLobbyError = payload?.message || JSON.stringify(payload);
      console.warn('[Network] lobby error', payload);
    });

    // register our profile with the lobby (do not block if wallet missing — send null)
    const address = (walletService && walletService.getAddress) ? walletService.getAddress() : null;
    const displayName = (walletService && walletService.getDisplayName)
      ? (walletService.getDisplayName() || (address ? `${address.slice(0,6)}…${address.slice(-4)}` : 'Guest'))
      : (address ? `${address.slice(0,6)}…${address.slice(-4)}` : 'Guest');

    try {
      await this.registerLobby(address, displayName);
    } catch (e) {
      console.warn('[Network] registerLobby failed', e);
      // still continue — lobby join itself succeeded
    }

    console.info('[Network] joined lobby', { roomId: this.lobbyRoom.roomId, sessionId: this.sessionId });
    return this.lobbyRoom;
  }

  async registerLobby(address, displayName) {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    try {
      // colyseus Room.send is synchronous; use try/catch for safety
      this.lobbyRoom.send('register', { address: address ? address.toLowerCase() : null, displayName });
    } catch (e) {
      throw e;
    }
  }

  async sendInvite({ toSessionId = null, toAddress = null } = {}) {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    try {
      this.lobbyRoom.send('invite', { toSessionId, toAddress });
    } catch (e) {
      console.warn('[Network] sendInvite failed', e);
      throw e;
    }
  }

  async joinSquad(squadId, leaderId) {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    this.lobbyRoom.send('join_squad', { squadId, leaderId });
  }

  async leaveSquad(squadId) {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    this.lobbyRoom.send('leave_squad', { squadId });
  }

  async setReady(squadId, ready) {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    this.lobbyRoom.send('set_ready', { squadId, ready });
  }

  async startMatchAsLeader(squadId) {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    this.lobbyRoom.send('start_match', { squadId });
  }

  async startMatchmaking() {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    this.lobbyRoom.send('start_matchmaking', {});
  }

  async stopMatchmaking() {
    if (!this.lobbyRoom) throw new Error('not-in-lobby');
    this.lobbyRoom.send('stop_matchmaking', {});
  }

  // ---------------- Game room join ----------------
  async joinGameRoomById(roomId) {
    if (this.gameRoom && this.gameRoom.roomId === roomId) {
      console.debug('[Network] already in game room', roomId);
      return this.gameRoom;
    }

    // default: dev-friendly skipAuth unless explicitly set to "false"
    const skipAuth = (import.meta.env.VITE_SKIP_GAME_AUTH === 'false') ? false : true;

    // ensure we leave lobby first to avoid duplicate sessions
    if (this.lobbyRoom) {
      try { await this.leaveLobby(); } catch (e) { console.warn('[Network] leaveLobby failed', e); }
      this.lobbyRoom = null;
    }

    // prepare stable playerId (wallet address preferred)
    const addrRaw = (typeof walletService !== 'undefined' && walletService.getAddress) ? walletService.getAddress() : null;
    const addr = addrRaw ? addrRaw.toLowerCase() : null;
    const playerId = addr || null;

    if (skipAuth) {
      this.gameRoom = await this.colyseusClient.joinById(roomId, { playerId });
      this.sessionId = this.gameRoom.sessionId;

      // ensure consistent lowercase player key
      this.playerKey = (playerId || this.sessionId);
      if (this.playerKey && typeof this.playerKey === 'string') {
        this.playerKey = this.playerKey.toLowerCase();
      }

      this._attachGameRoomHandlers();
      return this.gameRoom;

    }

    // production path: fetch nonce and sign
    const address = addr ? addr.toLowerCase() : this.sessionId;
    if (!address) throw new Error('wallet-not-connected');

    const base = import.meta.env.VITE_LOBBY_HTTP || 'http://localhost:2567';
    const r = await fetch(`${base}/nonce/${address}`);
    if (!r.ok) throw new Error('nonce-failed');
    const { nonce } = await r.json();

    const signature = await walletService.provider.request({
      method: 'personal_sign',
      params: [nonce, address]
    });

    // join with retry/backoff
    const maxAttempts = 7;
    let attempt = 0;
    while (attempt < maxAttempts) {
      try {
        this.gameRoom = await this.colyseusClient.joinById(roomId, { 
          playerId: address, 
          address, 
          signature, 
          nonce 
        });
        this.sessionId = this.gameRoom.sessionId;

        // ensure consistent lowercase player key
        this.playerKey = (playerId || this.sessionId);
        if (this.playerKey && typeof this.playerKey === 'string') {
          this.playerKey = this.playerKey.toLowerCase();
        }
        this._attachGameRoomHandlers();
        return this.gameRoom;

      } catch (e) {
        attempt++;
        const isNotFound = e?.name === 'MatchMakeError' && /not found/i.test(e.message);
        if (isNotFound && attempt < maxAttempts) {
          await new Promise(r => setTimeout(r, 150 * attempt));
          continue;
        }
        throw e;
      }
    }
    throw new Error('join-failed-after-retries');
  }

  _attachGameRoomHandlers() {
    if (!this.gameRoom) return;
    this.gameRoom.onStateChange((s) => { this.gameState = s; });
    this.gameRoom.onMessage('player_dead', (m) => { this._lastPlayerDead = m; });
    this.gameRoom.onMessage('gameover', (m) => { this._lastGameOver = m; });
    this.sessionId = this.gameRoom.sessionId;
    console.info('[Network] joined game room', { roomId: this.gameRoom.roomId, sessionId: this.sessionId, playerKey: this.playerKey });
  }

  async joinRoom(roomId = null) {
    if (roomId) return this.joinGameRoomById(roomId);
    if (this.gameRoom) return this.gameRoom;
    if (this._lastGameReady?.roomId) return this.joinGameRoomById(this._lastGameReady.roomId);
    throw new Error('no-room-to-join');
  }

  sendInput(input) {
    try {
      if (!this.gameRoom) {
        console.warn('[Network] sendInput skipped — not in game room');
        return;
      }
        input.seq = (this._inputSeq = (this._inputSeq || 0) + 1);

        // ensure lowercase playerKey is always attached
        if (!input.playerKey && this.playerKey) {
          input.playerKey = this.playerKey.toLowerCase();
        }
        console.debug('[Network] sending input', input);

        this.gameRoom.send('input', input);

    } catch (e) {
      console.error('[Network] sendInput error', e);
    }
  }

  async leaveLobby() {
    if (this.lobbyRoom) {
      try {
        await this.lobbyRoom.leave();
      } catch (e) {
        console.warn('[Network] leaveLobby error', e);
      } finally {
        this.lobbyRoom = null;
        this.lobbyState = null;
      }
    }
  }

  async leaveGame() {
    if (this.gameRoom) {
      try {
        await this.gameRoom.leave();
      } catch (e) {
        console.warn('[Network] leaveGame error', e);
      } finally {
        this.gameRoom = null;
        this.gameState = null;
      }
    }
  }
}

export const networkService = new NetworkService();
















//NET SYNC CODE

export default class NetSync {
  constructor(networkService, scene, opts = {}) {
    this.networkService = networkService;
    this.scene = scene;

    // interpolation delay: increase for smoother playback; you can lower if you want fresher
    this.INTERP_MS = opts.interpMs ?? 180; // default 180ms (tweakable)
    this.INPUT_HZ = opts.inputHz ?? 15;
    this.inputInterval = Math.round(1000 / this.INPUT_HZ);
    this._inputTimer = null;
    this._inputSeq = 0;

    this.snapshots = [];
    this.maxSnapshots = opts.maxSnapshots ?? 60;

    // modest local prediction by default so players feel immediate
    this.predStrength = (typeof opts.predStrength === 'number') ? opts.predStrength : 0.45;

    this._onState = null;
  }

  async start() {
    this._onState = (s) => {
      const snap = { t: Date.now(), tick: s.tick || 0, players: {}, enemies: {}, bullets: {} };
      // Players
      if (s.players && typeof s.players.toJSON === 'function') {
        const plainPlayers = s.players.toJSON();
        for (const id in plainPlayers) {
          const p = plainPlayers[id];
          snap.players[id] = { x: p.x, y: p.y, hp: p.hp, alive: p.alive, score: p.score, id };
        }
      } else {
        for (const [id, p] of Object.entries(s.players || {})) {
          snap.players[id] = { x: p.x, y: p.y, hp: p.hp, alive: p.alive, score: p.score, id };
        }
      }

      // Enemies
      if (s.enemies && typeof s.enemies.toJSON === 'function') {
        const plainEnemies = s.enemies.toJSON();
        for (const id in plainEnemies) {
          const e = plainEnemies[id];
          snap.enemies[id] = { x: e.x, y: e.y, hp: e.hp, alive: e.alive, id };
        }
      } else {
        for (const [id, e] of Object.entries(s.enemies || {})) {
          snap.enemies[id] = { x: e.x, y: e.y, hp: e.hp, alive: e.alive, id };
        }
      }

      // Bullets
      if (s.bullets && typeof s.bullets.toJSON === 'function') {
        const plainBullets = s.bullets.toJSON();
        for (const id in plainBullets) {
          const b = plainBullets[id];
          snap.bullets[id] = { x: b.x, y: b.y, vx: b.vx, vy: b.vy, owner: b.owner, id };
        }
      } else {
        for (const [id, b] of Object.entries(s.bullets || {})) {
          snap.bullets[id] = { x: b.x, y: b.y, vx: b.vx, vy: b.vy, owner: b.owner, id };
        }
      }

      this.snapshots.push(snap);
      if (this.snapshots.length > this.maxSnapshots) this.snapshots.shift();

      if (Math.random() < 0.03) {
        console.debug('[NetSync] snapshot', { t: snap.t, tick: snap.tick, players: Object.keys(snap.players).length, ids: Object.keys(snap.players).slice(0,6) });
      }
    };

    if (this.networkService.gameRoom && this.networkService.gameRoom.onStateChange) {
      this.networkService.gameRoom.onStateChange(this._onState);
    } else {
      // fallback: poll for room until it's ready
      const roomCheck = setInterval(() => {
        if (this.networkService.gameRoom && this.networkService.gameRoom.onStateChange) {
          this.networkService.gameRoom.onStateChange(this._onState);
          clearInterval(roomCheck);
        }
      }, 100);
    }

    this._startInputLoop();
  }

  stop() {
    try { this.networkService.gameRoom?.removeListener?.('state', this._onState); } catch (e) {}
    if (this._inputTimer) { clearInterval(this._inputTimer); this._inputTimer = null; }
    this.snapshots = [];
  }

  _startInputLoop() {
    if (this._inputTimer) return;
    this._inputTimer = setInterval(() => this._sendInputSnapshot(), this.inputInterval);
  }

  _sendInputSnapshot() {
    const reg = this.scene.registry.get('input') || null;
    let up = 0, down = 0, left = 0, right = 0, aimAngle = null;
    if (reg) {
      up = reg.vector?.y < -0.5 ? 1 : 0;
      down = reg.vector?.y > 0.5 ? 1 : 0;
      left = reg.vector?.x < -0.5 ? 1 : 0;
      right = reg.vector?.x > 0.5 ? 1 : 0;
      if (reg.aim) aimAngle = Math.atan2(reg.aim.y - (this.scene.player?.y || 0), reg.aim.x - (this.scene.player?.x || 0));
    } else {
      const keys = this.scene.keys;
      if (keys) {
        left = keys.A?.isDown ? 1 : 0;
        right = keys.D?.isDown ? 1 : 0;
        up = keys.W?.isDown ? 1 : 0;
        down = keys.S?.isDown ? 1 : 0;
      }
    }

    const input = { seq: ++this._inputSeq, up: !!up, down: !!down, left: !!left, right: !!right, aimAngle };
    try {
      // prefer networkService.sendInput convenience method if available
      if (typeof this.networkService.sendInput === 'function') {
        this.networkService.sendInput(input);
      } else if (this.networkService.gameRoom && typeof this.networkService.gameRoom.send === 'function') {
        this.networkService.gameRoom.send('input', input);
      } else {
        console.warn('[NetSync] no networkService.sendInput or gameRoom.send available');
      }
      console.debug(`[NetSync] sendInput seq=${input.seq} up=${input.up} down=${input.down} left=${input.left} right=${input.right}`);

      // small local prediction nudge so movement is responsive:
      if (this.scene.player && this.predStrength > 0) {
        const speed = (this.scene.CFG?.player?.speed || 80);
        const dt = (this.inputInterval / 1000);
        this.scene.player.x += ((right - left) * speed) * dt * this.predStrength;
        this.scene.player.y += ((down - up) * speed) * dt * this.predStrength;
      }
    } catch (e) {
      console.debug('[NetSync] sendInput failed', e?.message || e);
    }
  }

  // interpolation helpers
  _findSnapshotsFor(renderTime) {
    if (this.snapshots.length < 2) return null;
    let i = this.snapshots.findIndex(s => s.t > renderTime);
    if (i <= 0) return null;
    return { older: this.snapshots[i - 1], newer: this.snapshots[i] };
  }

  _lerp(a, b, t) { return a + (b - a) * t; }

  renderInterpolated(callback) {
    const renderTime = Date.now() - this.INTERP_MS;
    const pair = this._findSnapshotsFor(renderTime);

    // fallback to latest snapshot if we can't interpolate
    if (!pair) {
      const latest = this.snapshots[this.snapshots.length - 1];
      if (!latest) return callback({ players: {}, enemies: {}, bullets: {}, snapshotMeta: { playersIds: [] } });
      const myKey = this.networkService.playerKey || this.networkService.sessionId;
      console.log('[NetSync] fallback snapshot keys:', Object.keys(latest.players), 'myKey:', myKey);
      return callback({
        players: latest.players,
        enemies: latest.enemies,
        bullets: latest.bullets,
        snapshotMeta: { playersIds: Object.keys(latest.players) }
      });
    }

    const { older, newer } = pair;
    const denom = Math.max(1, (newer.t - older.t));
    let factor = (renderTime - older.t) / denom;
    factor = Math.max(0, Math.min(1, factor)); // clamp to [0,1]

    const safeNum = (v, fallback = 0) => (typeof v === 'number' && Number.isFinite(v) ? v : fallback);
    const unionKeys = (a = {}, b = {}) => {
      const set = new Set();
      Object.keys(a).forEach(k => set.add(k));
      Object.keys(b).forEach(k => set.add(k));
      return Array.from(set);
    };

    // players: use union of keys so removals/creates are handled
    const outPlayers = {};
    const playerIds = unionKeys(older.players, newer.players);
    for (const id of playerIds) {
      const oa = older.players[id];
      const nb = newer.players[id];

      if (!oa && nb) {
        outPlayers[id] = { x: safeNum(nb.x), y: safeNum(nb.y), hp: safeNum(nb.hp), alive: !!nb.alive, score: safeNum(nb.score) };
        continue;
      }
      if (!nb && oa) {
        outPlayers[id] = { x: safeNum(oa.x), y: safeNum(oa.y), hp: safeNum(oa.hp), alive: !!oa.alive, score: safeNum(oa.score) };
        continue;
      }
      // both exist: interpolate numeric fields
      const ix = this._lerp(safeNum(oa.x), safeNum(nb.x), factor);
      const iy = this._lerp(safeNum(oa.y), safeNum(nb.y), factor);
      const ihp = this._lerp(safeNum(oa.hp), safeNum(nb.hp), factor);
      outPlayers[id] = { x: ix, y: iy, hp: ihp, alive: !!nb.alive, score: safeNum(nb.score) };
    }

    // enemies
    const outEnemies = {};
    const enemyIds = unionKeys(older.enemies, newer.enemies);
    for (const id of enemyIds) {
      const oa = older.enemies[id];
      const nb = newer.enemies[id];
      if (!oa && nb) {
        outEnemies[id] = { x: safeNum(nb.x), y: safeNum(nb.y), hp: safeNum(nb.hp), alive: !!nb.alive };
        continue;
      }
      if (!nb && oa) {
        outEnemies[id] = { x: safeNum(oa.x), y: safeNum(oa.y), hp: safeNum(oa.hp), alive: !!oa.alive };
        continue;
      }
      const ix = this._lerp(safeNum(oa.x), safeNum(nb.x), factor);
      const iy = this._lerp(safeNum(oa.y), safeNum(nb.y), factor);
      const ihp = this._lerp(safeNum(oa.hp), safeNum(nb.hp), factor);
      outEnemies[id] = { x: ix, y: iy, hp: ihp, alive: !!nb.alive };
    }

    // bullets
    const outBullets = {};
    const bulletIds = unionKeys(older.bullets, newer.bullets);
    for (const id of bulletIds) {
      const oa = older.bullets[id];
      const nb = newer.bullets[id];
      if (!oa && nb) {
        outBullets[id] = { x: safeNum(nb.x), y: safeNum(nb.y), vx: safeNum(nb.vx), vy: safeNum(nb.vy), owner: nb.owner };
        continue;
      }
      if (!nb && oa) {
        outBullets[id] = { x: safeNum(oa.x), y: safeNum(oa.y), vx: safeNum(oa.vx), vy: safeNum(oa.vy), owner: oa.owner };
        continue;
      }
      const ix = this._lerp(safeNum(oa.x), safeNum(nb.x), factor);
      const iy = this._lerp(safeNum(oa.y), safeNum(nb.y), factor);
      const ivx = this._lerp(safeNum(oa.vx), safeNum(nb.vx), factor);
      const ivy = this._lerp(safeNum(oa.vy), safeNum(nb.vy), factor);
      outBullets[id] = { x: ix, y: iy, vx: ivx, vy: ivy, owner: nb.owner };
    }

    const myKey = this.networkService.playerKey || this.networkService.sessionId;
    console.log('[NetSync] interpolated snapshot keys:', playerIds, 'myKey:', myKey);

    callback({
      players: outPlayers,
      enemies: outEnemies,
      bullets: outBullets,
      snapshotMeta: { playersIds: playerIds }
    });
  }
}
